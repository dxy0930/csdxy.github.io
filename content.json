{"meta":{"title":"Medivh之家","subtitle":"","description":"","author":"Medivh","url":"https://dxy0930.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"04-12","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"04-12","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"04-12","excerpt":""},{"title":"目录","text":"","path":"categories/index.html","date":"04-12","excerpt":""},{"title":"关于我","text":"某个咸鱼的安卓学习者","path":"about/index.html","date":"04-13","excerpt":""}],"posts":[{"title":"新生赛第8题","text":"pc的三角形Description给你一个绳子长度为n,分成三段长度为整数的小绳子,输出这三段小绳子组成不同的三角形的个数与组成等腰三角形的个数 如果三角形A不能通过二维旋转操作得到三角形B,那么就视A,B为不同的三角形 Input第一行一个整数t,代表样例个数 接下来t行,每行一个个整数n代表绳子的长度(1≤t≤50，3 ≤n≤100) ##Outputt行,每行两个整数p , q分别代表不同的三角形个数和等腰三角形个数 ##Sample Input 1 234##Sample Output 1 1 10 0 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;string&gt; v;vector&lt;string&gt; v2;void add(int a, int b, int c) &#123; string s1 = to_string(a) + &quot; &quot; + to_string(b) + &quot; &quot; + to_string(c); string s2 = to_string(b) + &quot; &quot; + to_string(c) + &quot; &quot; + to_string(a); string s3 = to_string(c) + &quot; &quot; + to_string(a) + &quot; &quot; + to_string(b); for (vector&lt;string&gt;::iterator iter = v.begin(); iter != v.end(); ++iter) &#123; string t = *iter; if (t == s1 || t == s2 || t == s3) &#123; return; &#125; &#125; v.push_back(s1); if (a == b || a == c || b == c) &#123; for (vector&lt;string&gt;::iterator iter = v2.begin(); iter != v2.end(); ++iter) &#123; string t = *iter; if (t == s1 || t == s2 || t == s3) &#123; return; &#125; &#125; v2.push_back(s1); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; int t; cin &gt;&gt; t; for (int j = 1; j &lt;= t - 2; ++j) &#123; for (int k = 1; k &lt;= t - 1; ++k) &#123; int l = t - j - k; if (l &lt;= 0) break; if (j + k &lt;= l || j + l &lt;= k || k + l &lt;= j) &#123; continue; &#125; add(j, k, l); &#125; &#125; cout &lt;&lt; v.size() &lt;&lt; &quot; &quot; &lt;&lt; v2.size() &lt;&lt; endl; v.clear(); v2.clear(); &#125; return 0;&#125; 题解有空补上","path":"2020/10/23/Acm202008/","date":"10-23","excerpt":"","tags":[]},{"title":"新生赛第7题","text":"dl的会长Description众所周知,会长是协会权力最大的dl了,为了新生能有更好的参赛体验（其实是为了毒瘤新生）,他决定利用他的权力对其他出题人的题目难度进行修改,但其他出题人cbb(最毒瘤)当然会不服气，所以会长决定用金钱收买他们，会长可以花1元使任何一道题目的难度增加1或者减少1 (每道题可以操作任意次),现在他想使得所有题目难度一致，问他最少要花费多少钱。 Input四个整数a ,b,c,d ,分别代表现有的四个题目的难度(0 &lt;= a,b,c,d &lt;= 1000,000,0000≤a,b,c,d≤1000,000,000)。 Output会长使这四个题难度一致的最小花费。 代码12345678910111213#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; long long a[4]; for (int i = 0; i &lt; 4; ++i) &#123; cin&gt;&gt;a[i]; &#125; sort(a,a+4); long long res = a[1]-a[0] + a[2] - a[1] + a[3] - a[1]; cout&lt;&lt;res; return 0;&#125; 题解从小到大排序后，中位数的点即为到其他各点距离之和最小的点。证明略（建议百度）","path":"2020/10/23/Acm202007/","date":"10-23","excerpt":"","tags":[]},{"title":"新生赛第1题","text":"zw吃外卖Descriptionzw是集训队19级里的神之一。他有个习惯就是点外卖吃，他说这并不是因为懒得去食堂，是因为这样能省下时间来刷题，或许这就是神吧。但神也有神的烦恼，他的外卖总是被人拿走，如果找不回来的话就只能吃难吃的面包了。万幸的是热心的qc帮他找到了他的外卖，zw非常开心。顺手把眼前的题目秒了。他有点累了，需要休息一会。但眼前又有了新的问题，qc十分崇拜作为神的zw，想让zw帮qc算算他什么时候能脱单。zw告诉了你计算的方法，如果qc现在离寝室距离为奇数他就能脱单，否则不能，你能算出qc到底能不能脱单吗 Input输入一个整数a代表距离(1≤a≤1000,000,000) Output输出YES或NO（注意大小写） 代码1234567891011121314#include&lt;iostream&gt;using namespace std;int main() &#123; unsigned long long a; cin&gt;&gt;a; bool isOdd = a%2; if (isOdd)&#123; cout&lt;&lt;&quot;YES&quot;; &#125;else&#123; cout&lt;&lt;&quot;NO&quot;; &#125; return 0;&#125; 题解判断奇偶即可","path":"2020/10/23/Acm202001/","date":"10-23","excerpt":"","tags":[]},{"title":"体验碎片的活动周期部分代码","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class RightFragment extends Fragment &#123; public static final String TAG = \"RightFragment\"; @Override public void onAttach(Context context) &#123; super.onAttach(context); Log.d(TAG, \"onAttach\"); &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(TAG, \"onCreate\"); &#125; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.right_fragment,container,false); Log.d(TAG, \"onCreateView\"); return view; &#125; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); Log.d(TAG, \"onActivityCreated\"); &#125; @Override public void onStart() &#123; super.onStart(); Log.d(TAG, \"onStart\"); &#125; @Override public void onResume() &#123; super.onResume(); Log.d(TAG, \"onResume\"); &#125; @Override public void onPause() &#123; super.onPause(); Log.d(TAG, \"onPause\"); &#125; @Override public void onStop() &#123; super.onStop(); Log.d(TAG, \"onStop\"); &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); Log.d(TAG, \"onDestroyView\"); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, \"onDestroy\"); &#125; @Override public void onDetach() &#123; super.onDetach(); Log.d(TAG, \"onDetach\"); &#125;&#125;","path":"2020/04/13/SuiPianLife/","date":"04-13","excerpt":"","tags":[]},{"title":"碎片的通讯","text":"碎片与活动间的通讯活动获得碎片实例碎片与活动之间的通信可以使用FragmentManager提供的类似findViewById()的方法。 1RightFragment rightFragment = (RightFragment) getSupportFragmentManager().findFragmentById(R.id.right_fragment); 通过以上语句可以获得一个相应碎片实例，然后便可以通过实例来调用碎片的相关方法。 碎片获得活动的实例碎片可以通过getActivity()得到活动实例 1MainActivity activity = (MainActivity) getActivity(); ##碎片与碎片之间的通讯可以通过碎片-活动-碎片的过程进行通讯。","path":"2020/04/11/SuiPian/","date":"04-11","excerpt":"","tags":[]}],"categories":[],"tags":[]}